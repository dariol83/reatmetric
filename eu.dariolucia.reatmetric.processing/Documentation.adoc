==== Overview
The eu.dariolucia.reatmetric.processing module provides an implementation of the IProcessingModel interface specified in
the API module. Such model defines the M&C structure of the system(s) monitored by ReatMetric, in terms of system
elements, parameters, events, activities.

Upon loading the definitions of the model, this module builds a graph of dependencies across the various entities, in
order to understand which entity state needs to be recomputed, when another entity state changes. For instance, synthetic
parameters defined by expressions are recomputed only upon change of their input parameters. With the derivation of the
topological ordering of the entities, it is ensured that the number of entity state recomputations is only one per set of
updates.

In addition, the graph is used to determine when two requests for parameter/event updates can be processed in parallel,
because there is no processing overlap between the two requests. For instance, if two set of parameter updates are
provided at the same time (e.g. since they come from the monitoring of two separate devices), then the processing will
be performed in parallel by two different execution threads. Of course, this happens only if there is no 'shared entity'
affected by the two updates. For instance, if a synthetic parameter is defined, having parameters coming from two
different devices as input parameters, then the updates will be serialised due to the synthetic parameter presence.

Since the topological ordering is an expensive operation, the module might create a cache the first time this ordering is
computed, generating a file named ".ordering.cache", and reuse this cache every time the model is loaded again.

In terms of activity dispatching, activity handlers need to be registered to the processing model implementation via
the methods defined in the IProcessingModel interface. At registration time, the processing model enquiries the activity
handler about the supported routes and keeps a correspondence between the route and the activity handler. An activity
handler also reports which type of activity it supports. The type is a simple string and it must be assigned to each
activity in the processing definition.

All state updates generated by the processing model are sent to a single sink: this approach is not specified by the
IProcessingModel interface, but it is a characteristic of this implementation.

This module has one internal dependency:

* On eu.dariolucia.reatmetric.api

This module has two external dependencies:

* On JAXB library, since the processing definitions are defined in XML files;
* On Groovy library, since expression-based checks, expression-based calibrations, parameter-based verifications for
activities and synthetic parameters/events are defined using Groovy as scripting language.

==== Configuration
The configuration of the processing module via the processing definition XML files is complex, but it can be
broken down to configuration elements that are simpler to understand. The configuration structure is defined in the
package eu.dariolucia.reatmetric.processing.definition. It is one or more XML files using namespace definition
_http://dariolucia.eu/reatmetric/processing/definition_.

A commented example of such file (broken down in parts) is presented below.

===== Root element
The XML definition file has a root node named _processing_.

[source,xml]
----
<ns1:processing xmlns:ns1="http://dariolucia.eu/reatmetric/processing/definition">
    <parameters>
    ...
    </parameters>
    <events>
    ...
    </events>
    <activities>
    ...
    </activities>
</ns1:processing>
----

The _processing_ node has the following optional attributes:

_synthetic_parameter_processing_enabled_: default is 'true'. When set to 'false', the processing of synthetic parameters
will be disabled. However, if more than one file is used to build up the configuration and one of these files has this
attribute set to false, the processing of the synthetic parameters will be disabled for all definitions in all files.

_mirrored_: default is 'false'. This flag is used to indicate that the elements described in the
file are managed by a separate processing model. When set to 'true', the processing model will only process updates coming from the mirror()
method, and will not recomputed/recalculate any value.

_path_prefix_: default is empty. When set to a string, e.g. 'STATION.DEVICE3.', the path will be prefixed to all configured
locations of the elements defined in the file. This approach is particularly useful in case some definitions of a separate
processing model must be imported in a different processing model for mirroring and must appear in a specific sub-branch
of the hierarchical decomposition.

===== Parameters

The _parameters_ element contains zero or more _parameter_ elements. An example is provided in the XML fragment below.

[source,xml]
----
<parameter id="#170"
    location="SUB1.STATUS"
    description="Subsystem Status"
    raw_type="ENUMERATED"
    eng_type="CHARACTER_STRING"
    eng_unit=""
    log_repetition_period="2000"
    user_parameter="false">
    <calib_enum default="UNKNOWN">
        <point x="0" y="OFF" />
        <point x="1" y="ON" />
    </calib_enum>
    <setter activity="#104" set_argument="new_value">
        <!-- Convert? -->
        <decalib_ienum>
            <point y="0" x="OFF" />
            <point y="1" x="ON" />
        </decalib_ienum>
        <fixed_argument name="device_subsystem" value="1" raw_value="true" />
        <fixed_argument name="parameter" value="0" raw_value="true" />
    </setter>
</parameter>
----

The _parameter_ node has the following attributes:

_id_: mandatory special string. The string is a positive integer number, prefixed with the hash # symbol. The number must be unique among all
system element ids defined in the ReatMetric model under monitoring, including those defined in separate processing models.

_location_: mandatory string. This string represents the location of the parameter in the hierarchical decomposition. Each
element of the hierarchy is separated by a dot .

_description_: mandatory string. The description of the parameter.

_raw_type_: mandatory enumerated value. The type of the source value: when a parameter sample is injected into the model, the source value
of the parameter sample must have this type.

_eng_type_: mandatory enumerated value. The output type of the parameter, after the processing.

_eng_unit_: default is empty string. The unit of the parameter engineering value.

_log_repetition_period_: default is 0 (disabled). The minimum log generation period in milliseconds. If an alarm generates
a log within the minimum repetition period window, the log message is skipped and a counter increased. This is a way to
limit log flooding for parameters in case of high sampling rates.

_user_parameter_: default is 'false'. This attribute indicates whether a parameter must be considered a user-parameter,
i.e. not linked to external device parameters but rather settable directly from users, drivers or other ReatMetric elements and
not via a setter element, which is mapped to an activity for dispatching and remote execution. User parameters can be
considered 'internal' parameters, which can be useful to define globally available values and properties, with all the
processing capabilities of validity, calibrations, checks and triggers available for standard parameters.

The _parameter_ node has the following sub-elements:

_validity_

_synthetic_

_default_value_

_calib_x_

_checks_

_setter_

_triggers_



===== Events

===== Activities