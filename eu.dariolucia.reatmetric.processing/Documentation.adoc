==== Overview
The eu.dariolucia.reatmetric.processing module provides an implementation of the IProcessingModel interface specified in
the API module. Such model defines the M&C structure of the system(s) monitored by ReatMetric, in terms of system
elements, parameters, events, activities.

Upon loading the definitions of the model, this module builds a graph of dependencies across the various entities, in
order to understand which entity state needs to be recomputed, when another entity state changes. For instance, synthetic
parameters defined by expressions are recomputed only upon change of their input parameters. With the derivation of the
topological ordering of the entities, it is ensured that the number of entity state recomputations is only one per set of
updates.

In addition, the graph is used to determine when two requests for parameter/event updates can be processed in parallel,
because there is no processing overlap between the two requests. For instance, if two set of parameter updates are
provided at the same time (e.g. since they come from the monitoring of two separate devices), then the processing will
be performed in parallel by two different execution threads. Of course, this happens only if there is no 'shared entity'
affected by the two updates. For instance, if a synthetic parameter is defined, having parameters coming from two
different devices as input parameters, then the updates will be serialised due to the synthetic parameter presence.

Since the topological ordering is an expensive operation, the module might create a cache the first time this ordering is
computed, generating a file named ".ordering.cache", and reuse this cache every time the model is loaded again.

In terms of activity dispatching, activity handlers need to be registered to the processing model implementation via
the methods defined in the IProcessingModel interface. At registration time, the processing model enquiries the activity
handler about the supported routes and keeps a correspondence between the route and the activity handler. An activity
handler also reports which type of activity it supports. The type is a simple string and it must be assigned to each
activity in the processing definition.

All state updates generated by the processing model are sent to a single sink: this approach is not specified by the
IProcessingModel interface, but it is a characteristic of this implementation.

This module has one internal dependency:

* On eu.dariolucia.reatmetric.api

This module has two external dependencies:

* On JAXB library, since the processing definitions are defined in XML files;
* On Groovy library, since expression-based checks, expression-based calibrations, parameter-based verifications for
activities and synthetic parameters/events are defined using Groovy as scripting language.

==== Configuration
To be written
