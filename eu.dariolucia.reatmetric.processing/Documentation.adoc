==== Overview
The eu.dariolucia.reatmetric.processing module provides an implementation of the IProcessingModel interface specified in
the API module. Such model defines the M&C structure of the system(s) monitored by ReatMetric, in terms of system
elements, parameters, events, activities.

Upon loading the definitions of the model, this module builds a graph of dependencies across the various entities, in
order to understand which entity state needs to be recomputed, when another entity state changes. For instance, synthetic
parameters defined by expressions are recomputed only upon change of their input parameters. With the derivation of the
topological ordering of the entities, it is ensured that the number of entity state recomputations is only one per set of
updates.

In addition, the graph is used to determine when two requests for parameter/event updates can be processed in parallel,
because there is no processing overlap between the two requests. For instance, if two set of parameter updates are
provided at the same time (e.g. since they come from the monitoring of two separate devices), then the processing will
be performed in parallel by two different execution threads. Of course, this happens only if there is no 'shared entity'
affected by the two updates. For instance, if a synthetic parameter is defined, having parameters coming from two
different devices as input parameters, then the updates will be serialised due to the synthetic parameter presence.

Since the topological ordering is an expensive operation, the module might create a cache the first time this ordering is
computed, generating a file named ".ordering.cache", and reuse this cache every time the model is loaded again.

In terms of activity dispatching, activity handlers need to be registered to the processing model implementation via
the methods defined in the IProcessingModel interface. At registration time, the processing model enquiries the activity
handler about the supported routes and keeps a correspondence between the route and the activity handler. An activity
handler also reports which type of activity it supports. The type is a simple string and it must be assigned to each
activity in the processing definition.

All state updates generated by the processing model are sent to a single sink: this approach is not specified by the
IProcessingModel interface, but it is a characteristic of this implementation.

This module has one internal dependency:

* On eu.dariolucia.reatmetric.api

This module has two external dependencies:

* On JAXB library, since the processing definitions are defined in XML files;
* On Groovy library, since expression-based checks, expression-based calibrations, parameter-based verifications for
activities and synthetic parameters/events are defined using Groovy as scripting language.

==== Configuration
The configuration of the processing module via the processing definition XML files is complex, but it can be
broken down to configuration elements that are simpler to understand. The configuration structure is defined in the
package eu.dariolucia.reatmetric.processing.definition. It is one or more XML files using namespace definition
_http://dariolucia.eu/reatmetric/processing/definition_.

A commented example of such file (broken down in parts) is presented below.

===== Root element
The XML definition file has a root node named _processing_.

[source,xml]
----
<ns1:processing xmlns:ns1="http://dariolucia.eu/reatmetric/processing/definition">
    <parameters>
    ...
    </parameters>
    <events>
    ...
    </events>
    <activities>
    ...
    </activities>
</ns1:processing>
----

The _processing_ node has the following optional attributes:

_synthetic_parameter_processing_enabled_: default is 'true'. When set to 'false', the processing of synthetic parameters
will be disabled. However, if more than one file is used to build up the configuration and one of these files has this
attribute set to false, the processing of the synthetic parameters will be disabled for all definitions in all files.

_mirrored_: default is 'false'. This flag is used to indicate that the elements described in the
file are managed by a separate processing model. When set to 'true', the processing model will only process updates coming from the mirror()
method, and will not recomputed/recalculate any value.

_path_prefix_: default is empty. When set to a string, e.g. 'STATION.DEVICE3.', the path will be prefixed to all configured
locations of the elements defined in the file. This approach is particularly useful in case some definitions of a separate
processing model must be imported in a different processing model for mirroring and must appear in a specific sub-branch
of the hierarchical decomposition.

===== Parameters

The _parameters_ element contains zero or more _parameter_ elements. An example is provided in the XML fragment below.

[source,xml]
----
<parameter id="#170"
    location="SUB1.STATUS"
    description="Subsystem Status"
    raw_type="ENUMERATED"
    eng_type="CHARACTER_STRING"
    eng_unit=""
    log_repetition_period="2000"
    user_parameter="false">
    <validity>
        <matcher parameter="#312"
            operator="EQUAL"
            value="32"
            value_type="ENUMERATED"
            use_raw_value="true" />
    </validity>
    <calib_enum default="UNKNOWN">
        <point x="0" y="OFF" />
        <point x="1" y="ON" />
    </calib_enum>
    <checks>
        <expected type="CHARACTER_STRING">
            <value>ON</value>
        </expected>
    </checks>
    <setter activity="#104" set_argument="new_value">
        <!-- Convert? -->
        <decalib_ienum>
            <point y="0" x="OFF" />
            <point y="1" x="ON" />
        </decalib_ienum>
        <fixed_argument name="device_subsystem" value="1" raw_value="true" />
        <fixed_argument name="parameter" value="0" raw_value="true" />
    </setter>
    <triggers>
        <trigger condition="ON_VALUE_CHANGE" event="#123" />
    </triggers>
</parameter>
----

The _parameter_ node has the following attributes:

_id_: mandatory special string. The string is a positive integer number, prefixed with the hash # symbol. The number must be unique among all
system element ids defined in the ReatMetric model under monitoring, including those defined in separate processing models.

_location_: mandatory string. This string represents the location of the parameter in the hierarchical decomposition. Each
element of the hierarchy is separated by a dot .

_description_: mandatory string. The description of the parameter.

_raw_type_: mandatory enumerated value. The type of the source value: when a parameter sample is injected into the model, the source value
of the parameter sample must have this type.

_eng_type_: mandatory enumerated value. The output type of the parameter, after the processing.

_eng_unit_: default is empty string. The unit of the parameter engineering value.

_log_repetition_period_: default is 0 (disabled). The minimum log generation period in milliseconds. If an alarm generates
a log within the minimum repetition period window, the log message is skipped and a counter increased. This is a way to
limit log flooding for parameters in case of high sampling rates.

_user_parameter_: default is 'false'. This attribute indicates whether a parameter must be considered a user-parameter,
i.e. not linked to external device parameters but rather settable directly from users, drivers or other ReatMetric elements and
not via a setter element, which is mapped to an activity for dispatching and remote execution. User parameters can be
considered 'internal' parameters, which can be useful to define globally available values and properties, with all the
processing capabilities of validity, calibrations, checks and triggers available for standard parameters.

The _parameter_ node has the following sub-elements:

_validity_: optional, if not provided the parameter is always considered valid. The _validity_ element can contain either
a _match_ element or a _condition_ sub-element. A _match_ element is used to determine the validity based on a comparison
between the value (source or engineering) of a second parameter, and the value specified in the definition, with the related
operator (equal, higher, lower, not equal...). A _condition_ element specifies a Groovy expression that shall return
a boolean value upon evaluation.

_synthetic_: optional, to be provided only if the parameter shall be a synthetic parameter.
A synthetic parameter requires an expression to compute its source value: therefore, injection of
such parameters via the injectParameter() method will be rejected by the processing model.

_default_value_: optional, null if not provided. It allows to specify a default value (either raw or engineering)
that the processing model will initialise as default value upon instantiation.
Uninitialised parameters will have a Java null value as source and engineering value.

_calib_x_: optional (zero or more), no calibration if none is provided. When no calibration is assigned, the source/raw value is simply
assigned as engineering value. When provided, the calibration to be applied is selected by checking the list of specified
calibration in the order they appear in the definition, and the first calibration matching the applicability criterium is
selected and applied. If no applicability criterium is specified, then the calibration is always considered applicable. The
following calibrations are available:

* calib_xy: a list of x,y pairs is defined. The raw value must be defined as a number (integer, real, enumerated).
The engineering value must be defined as a real. The processing model computes the output linked to the provided input
number by linearly interpolating the y-value between the pair that  encloses the x-input. Extrapolation outside the minimum
and maximum x can be activated: it is de-activated by default. In such case, the processing model will reject the attempt
to calibrate a input outside the series-defined boundaries.
* calib_poly: the definition specifies 6 coefficients (from a0 to a5), which compose the polynomial function:
a0 + a1*x + a2*x^2 + a3*x^3 + a4*x^4 + a5*x^5. The raw value must be defined as a number (integer, real, enumerated).
The engineering value must be defined as real.
* calib_log: the definition specifies 6 coefficients (from a0 to a5), which compose the logarithmic function:
1/(a0 + a1*log(x) + a2*log(x)^2 + a3*log(x)^3 + a4*log(x)^4 + a5*log(x)^5). The raw value must be defined as a number
(integer, real, enumerated). The engineering value must be defined as real.
* calib_enum: a list of key,value pairs is defined, plus a default string value. The raw value must be defined as an
integer number or enumerated. The engineering value must be defined as string. The provided input number is mapped to the
corresponding textual value, or to the default value if no correspondence is found.
* calib_range_enum: a list of range-to-value pairs is defined. The raw value must be defined as a number (integer, real,
enumerated). The engineering value must be defined as string. Given the provided input number, the range containing it is
detected, and the corresponding textual value is returned as engineering value. If no range contains the provided input,
the default value is returned.
* calib_expression: input and output values can be of any type. The defined Groovy expression is used to compute the
output value.
* calib_external: input and output values can be of any type. The processing model uses the registered ICalibrationExtension
implementation, as specified in the definition, to request the calibration of the provided input value.

_checks_: optional (zero or more) checks can be specified inside the element _checks_. Checks are applied to the
engineering value of the parameter of a parameter by default (unless differently specified),
if the check applicability criteria is satisfied. If a check does not have an applicability criteria, the check is always
considered to be applied. By default, a violated check immediately raises an alarm: it is possible to modify the severity of
the check, as well as the number of consecutive checks that the check must fail before raising the failure.
The sub-elements of the _checks_ element are:

* limit: the value must be inside the low/high limit specified in the definition. If it is outside the limit, the
check is declared failed.
* expected: the value must match one of the values specified in the definition, otherwise the check is declared failed.
* delta: the difference between the new value and the previous value is computed. If such difference is not within the
low/high limit specified in the definition, the check is declared failed. The absolute (positive) difference can also be used.
* expression: a Groovy expression, returning a boolean value, is defined. If the evaluation of the definition returns
false, then the check is declared failed.
* external: The processing model uses the registered ICheckExtension implementation, as specified in the definition,
to request the check of the provided parameter.

_setter_: optional (zero or one) reference to an existing activity, which shall be used to set the value of the parameter
to a new value. The definition must specify which argument of the activity shall be set to the new value specified by the
user. The activity invocation is complemented by the list of fixed argument values, each mapping to an activity argument.
If such setter is specified, the SetParameterRequest will translate to an activity invocation. It is important to note that
the setter definition must specify a _complete_ activity invocation, i.e. all activity arguments must be specified. An
optional de-calibration can be specified (including inverted enumerations) to convert the value specified as engineering value
into raw value.

_triggers_: optional (zero or more) triggers can be specified inside the element _triggers_ (sub-node _trigger_). Triggers
can be linked to events, which are raised when there is a specific change in the parameter state. The specific change is
specified with the attribute _condition_ (which takes four possible values: ON_NEW_SAMPLE, ON_VALUE_CHANGED, ON_ALARM_RAISED,
ON_BACK_TO_NOMINAL), while the event to raise is specified in the attribute _event_.

===== Events

The _events_ element contains zero or more _event_ elements. An example is provided in the XML fragment below.

[source,xml]
----
<event id="#190"
    location="SUB1.STATE_CHANGE"
    description="Subsystem State Changed event"
    severity="INFO"
    type="Event Type 1"
    inhibition_period="1000"
    log_repetition_period="2000">
</event>
----

The _event_ node has the following attributes:

_id_: mandatory special string. The string is a positive integer number, prefixed with the hash # symbol. The number must be unique among all
system element ids defined in the ReatMetric model under monitoring, including those defined in separate processing models.

_location_: mandatory string. This string represents the location of the event in the hierarchical decomposition. Each
element of the hierarchy is separated by a dot .

_description_: mandatory string. The description of the event.

_severity_: optional, default is INFO. The severity of the event.

_type_: optional, default is empty string. The type of the event.

_inhibition_period_: optional default is 0 (disabled). The number of milliseconds between two reporting of the event. This is a
way to limit event flooding.

_log_repetition_period_: optional, default is 0 (disabled). The minimum log generation period in milliseconds. If an event generates
a log within the minimum repetition period window, the log message is skipped and a counter increased. This is a way to
limit log flooding for events.

_log_enabled_: optional, default is true (enabled). When set to false, the event does not generate log messages.

The _event_ node has the following sub-elements:

_condition_: optional, to be provided only if the event occurrence shall be computed by the processing model. The provided
Groovy expression shall return a boolean value: when a transition false -> true in the condition evaluation is detected, the
processing model raises the event.

===== Activities

The _activities_ element contains zero or more _activity_ elements. An example is provided in the XML fragment below.

[source,xml]
----
<activity id="#79" location="SUB1.REBOOT" description="Reboot subsystem" type="DEV3-BIN-CMD"
    verification_timeout="3000">
    <argument name="delay" raw_type="UNSIGNED_INTEGER" eng_type="UNSIGNED_INTEGER" eng_unit="" />
    <argument name="running" raw_type="UNSIGNED_INTEGER" eng_type="UNSIGNED_INTEGER" eng_unit="" />
    <property key="test1" value="V1" />
    <property key="test2" value="V2" />
    <verification>
        <expression>STATUS == "ON"</expression>
        <symbol name="STATUS" reference="#170" binding="ENG_VALUE" />
    </verification>
</activity>
----

The _activity_ node has the following attributes:

_id_: mandatory special string. The string is a positive integer number, prefixed with the hash # symbol. The number must be unique among all
system element ids defined in the ReatMetric model under monitoring, including those defined in separate processing models.

_location_: mandatory string. This string represents the location of the activity in the hierarchical decomposition. Each
element of the hierarchy is separated by a dot .

_description_: mandatory string. The description of the activity.

_type_: mandatory string. The type of the activity.

_default_route_: optional, null if not set. The route to be used in case no route is specified as part of the activity
invocation request.

_transmission_timeout_: optional, default is 0 (disabled). The number of seconds after entering the transmission state,
before the state of the specific activity occurrence goes in timeout.

_execution_timeout_: optional, default is 0 (disabled). The number of seconds after entering the transmission state,
before the state of the specific activity occurrence goes in timeout.

_verification_timeout_: optional, default is 0 (disabled). The number of seconds after entering the transmission state,
before the state of the specific activity occurrence goes in timeout.

_expected_duration_: optional, default is 1000. The expected duration of an activity occurrence execution, in milliseconds.

The _activity_ node has the following sub-elements:

_argument_:
_array_:
_property_:
_verification_:

===== Expressions