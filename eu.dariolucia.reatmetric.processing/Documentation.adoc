==== Overview
The eu.dariolucia.reatmetric.processing module provides an implementation of the IProcessingModel interface specified in
the API module. Such model defines the M&C structure of the system(s) monitored by ReatMetric, in terms of system
elements, parameters, events, activities.

Upon loading the definitions of the model, this module builds a graph of dependencies across the various entities, in
order to understand which entity state needs to be recomputed, when another entity state changes. For instance, synthetic
parameters defined by expressions are recomputed only upon change of their input parameters. With the derivation of the
topological ordering of the entities, it is ensured that the number of entity state recomputations is only one per set of
updates.

In addition, the graph is used to determine when two requests for parameter/event updates can be processed in parallel,
because there is no processing overlap between the two requests. For instance, if two set of parameter updates are
provided at the same time (e.g. since they come from the monitoring of two separate devices), then the processing will
be performed in parallel by two different processing threads. Of course, this happens only if there is no 'shared entity'
affected by the two updates. For instance, if a synthetic parameter is defined, having parameters coming from two
different devices as input parameters, then the updates will be serialised due to the synthetic parameter presence.

Since the topological ordering is an expensive operation, the module might create a cache the first time this ordering is
computed, generating a file named ".ordering.cache", and reuse this cache every time the model is loaded again.

In terms of activity dispatching, activity handlers need to be registered to the processing model implementation via
the methods defined in the IProcessingModel interface. At registration time, the processing model enquiries the activity
handler about the supported routes and keeps a correspondence between the route and the activity handler. An activity
handler also reports which type of activity it supports. The type is a simple string and it must be assigned to each
activity in the processing definition.

All state updates generated by the processing model are sent to a single sink: this approach is not specified by the
IProcessingModel interface, but it is a characteristic of this implementation.

This module has one internal dependency:

* On eu.dariolucia.reatmetric.api

This module has two external dependencies:

* On JAXB library, since the processing definitions are defined in XML files;
* On Groovy library, since expression-based checks, expression-based calibrations, parameter-based verifications for
activities and synthetic parameters/events are defined using Groovy as scripting language.

==== Behaviour
Once instantiated, the IProcessingModel implementation must be used according to the contract specified by the IProcessingModel
interface (check the related Javadoc). The processing of the related request is performed asynchronously, even if some parts
(e.g. the derivation of the unique ID mapped to an activity invocation request) are done synchronously, in order to return
a meaningful value to the caller.

Once a request is received by the processing model, it is routed to a specific dispatching queue:

* Requests linked to _reporting operations_ (parameter updates, requests to raise events, activity progress reports) are
added to a _reporting queue_
* Requests linked to _commanding operations_ (activity invocations, activity control operations, system element enable/disable)
are added to a _commanding queue_

The _commanding queue_ is of limited capacity (20000) and can therefore block the caller, if it becomes full.
Half of the queue is reserved for internal operations of the processing model that result in internal commanding requests,
to avoid deadlocks and delays in the processing of reporting operations. This means that, if more than half of the _commanding queue_
is full, externally requested commanding operations will block until at least half of the _commanding queue_ is empty.

The _reporting queue_ is of limited capacity (1000) and can therefore block the caller, if it becomes full. Backpressure is
hence generated in case the processing model is saturated.

Each queue has an associated dispatch thread, which is responsible to:

* Remove one item from the queue, containing the list of operations to be performed
* Finalize the list of operations by extending it with the necessary re-evaluations
* Identify the involved processors and the affected system elements
* Re-order the final list of operations according to the topological sort
* Record the affected system elements as part of the _working set_
* Request the implementation of the operations to the _processing thread pool_

The _working set_ identifies what system elements are currently under update by the _processing thread pool_. At the end of the
update, such system elements are removed from the working set. If there is an overlap between the working set and the
system elements affected by one list of operations (i.e. there is a processing conflict), the dispatch thread waits until
the conflict is resolved.

The _processing thread pool_ is a fixed thread pool, having a number of thread equals to the number of available processors
in the machine (Runtime.getRuntime().availableProcessors()). A thread in this pool is responsible to apply and process an
operation on the related system elements. Only the system elements having state ENABLED and IGNORED are processed.

Each operation on a system element generates a visible state (ParameterData, EventData, ActivityOccurrenceData,
AlarmParameterData), which is then delivered to the output sink provided in the constructor of the model implementation
(IProcessingModelOutput).

The processing model does not provide any subscription or archiving mechanisms: such functions are provided by the
eu.dariolucia.reatmetric.core module.

===== Parameter Processing
Parameter samples are injected into the model using the method: void injectParameters(List<ParameterSample>).

The processing is done according to the following logic:

. If the generation time of the sample is older than the generation time of the previous sample, the injected sample is
ignored and the processing is over
. The validity of the parameter is computed
. If the parameter is valid, then the engineering value is computed
. If the parameter is valid, then the alarm state is computed
. A ParameterData object is generated
. The alarm state is evaluated, to decide whether an AlarmParameterData object must be generated
. The defined triggers are evaluated

===== Event Processing
Events are injected into the model using the method: void raiseEvent(EventOccurrence).

The processing is done according to the following logic:

. If the event occurs within the defined inhibition period (based in generation time), then the injected event is ignored
and the processing is over
. A log message is generated, if the event does not lie in the log repetition inhibition period
. An EventData object is generated

Note that the generation time is not used to ignore events based on previous occurrences, as it is done for parameters.

===== Activity Processing
Execution of activities is requested using the method: IUniqueId startActivity(ActivityRequest).

The processing is done according to the following logic:

. The request is checked for its consistency: all arguments are present with the right type, the route is defined and it
is existing
. The activity occurrence is created
. The activity occurrence is forwarded to the handler linked to type and route, for implementation
. An ActivityOccurrenceData is generated

The IUniqueId returned by the method uniquely identifies the created activity occurrence in the system.

Progresses about the activity execution are injected into the model using the method: void reportActivityProgress(ActivityProgress).

The processing is done according to the following logic:
. The activity state is updated according to the ActivityProcess information
. If an activity state transition is detected, the timer for the timeout is started (if defined)
. An ActivityOccurrenceData is generated

The processing model defines specific verification stages: some of them *must* be used by callers as part of the
ActivityProgress objects, so that the correct transitions can take place:

. The constant ActivityOccurrenceReport.CREATION_REPORT_NAME ("Creation") is internally used by the processing model to
indicate the creation stage of the activity occurrence and it is the only stage of the activity state ActivityOccurrenceState.CREATION.
Its use is reserved and shall not be used by activity progresses.
. The constant ActivityOccurrenceReport.FORWARDING_REPORT_NAME ("Forwarding to Activity Handler") is announced by the processing
model as part of the activity state ActivityOccurrenceState.RELEASE. The stage indicates the forwarding phase of the activity
occurrence to the associated activity handler via the method IActivityHandler.executeActivity(). Any exception
raised by the handler is caught by the processing model and a FATAL result is reported associated to this stage.
The activity handler must report an OK linked to this stage, if the activity occurrence is accepted for release and
remain in the ActivityOccurrenceState.RELEASE activity state.
. The constant ActivityOccurrenceReport.RELEASE_REPORT_NAME ("Release") must be announced by the activity handler when
the encoded activity is about to leave the system and reported with a OK or FATAL depending on the result. Upon report,
the next state of the activity shall be moved to ActivityOccurrenceState.TRANSMISSION.
. The constant ActivityOccurrenceReport.VERIFICATION_REPORT_NAME ("Verification") is internally used by the processing model
when the activity state moved to ActivityOccurrenceState.VERIFICATION, as announced by the activity handler/driver that
monitors the progress of the activity occurrence.

An activity handler can report, for the TRANSMISSION and EXECUTION state, an unlimited number of verification stages.

The sequence of activity occurrence states is the following:

CREATION -> RELEASE -> (TRANSMISSION) -> (SCHEDULING) -> EXECUTION -> VERIFICATION

The TRANSMISSION and SCHEDULING states are optional: in fact, activity occurrences could be implemented by internal
ReatMetric functions/drivers, so the RELEASE state could be immediately followed by the EXECUTION state. The SCHEDULING
state is used when the activity occurrence is scheduled for execution at a later point in time on the remote device/equipment.

Upon entering the TRANSMISSION, EXECUTION and VERIFICATION states, the related timers defined in the definition (if present)
are started: the stages belonging to the state, that are PENDING at the expiration of the timer linked to the state,
are reported as TIMEOUT by the processing model.

===== Mirrored Elements
A processing model can be kept synchronised with the state of another processing model via the mirror(List<AbstractDataItem>)
method. The processing of such requests simply overwrite the state of the system element with the one provided as input.
Such requests are only considered for system entities marked as 'mirrored' in the definition.

==== Configuration
The configuration of the processing module via the processing definition XML files is complex, but it can be
broken down to configuration elements that are simpler to understand. The configuration structure is defined in the
package eu.dariolucia.reatmetric.processing.definition. It is one or more XML files using namespace definition
_http://dariolucia.eu/reatmetric/processing/definition_.

A commented example of such file (broken down in parts) is presented below.

===== Root element
The XML definition file has a root node named _processing_.

[source,xml]
----
<ns1:processing xmlns:ns1="http://dariolucia.eu/reatmetric/processing/definition">
    <parameters>
    ...
    </parameters>
    <events>
    ...
    </events>
    <activities>
    ...
    </activities>
</ns1:processing>
----

The _processing_ node has the following optional attributes:

_synthetic_parameter_processing_enabled_: default is 'true'. When set to 'false', the processing of synthetic parameters
will be disabled. However, if more than one file is used to build up the configuration and one of these files has this
attribute set to false, the processing of the synthetic parameters will be disabled for all definitions in all files.

_mirrored_: default is 'false'. This flag is used to indicate that the elements described in the
file are managed by a separate processing model. When set to 'true', the processing model will only process updates coming from the mirror()
method, and will not recomputed/recalculate any value.

_path_prefix_: default is empty. When set to a string, e.g. 'STATION.DEVICE3.', the path will be prefixed to all configured
locations of the elements defined in the file. This approach is particularly useful in case some definitions of a separate
processing model must be imported in a different processing model for mirroring and must appear in a specific sub-branch
of the hierarchical decomposition.

===== Parameters

The _parameters_ element contains zero or more _parameter_ elements. An example is provided in the XML fragment below.

[source,xml]
----
<parameter id="#170"
    location="SUB1.STATUS"
    description="Subsystem Status"
    raw_type="ENUMERATED"
    eng_type="CHARACTER_STRING"
    eng_unit=""
    log_repetition_period="2000"
    user_parameter="false">
    <validity>
        <matcher parameter="#312"
            operator="EQUAL"
            value="32"
            value_type="ENUMERATED"
            use_raw_value="true" />
    </validity>
    <calib_enum default="UNKNOWN">
        <point x="0" y="OFF" />
        <point x="1" y="ON" />
    </calib_enum>
    <checks>
        <expected type="CHARACTER_STRING">
            <value>ON</value>
        </expected>
    </checks>
    <setter activity="#104" set_argument="new_value">
        <!-- Convert? -->
        <decalib_ienum>
            <point y="0" x="OFF" />
            <point y="1" x="ON" />
        </decalib_ienum>
        <fixed_argument name="device_subsystem" value="1" raw_value="true" />
        <fixed_argument name="parameter" value="0" raw_value="true" />
    </setter>
    <triggers>
        <trigger condition="ON_VALUE_CHANGE" event="#123" />
    </triggers>
</parameter>
----

The _parameter_ node has the following attributes:

_id_: mandatory special string. The string is a positive integer number, prefixed with the hash # symbol. The number must be unique among all
system element ids defined in the ReatMetric model under monitoring, including those defined in separate processing models.

_location_: mandatory string. This string represents the location of the parameter in the hierarchical decomposition. Each
element of the hierarchy is separated by a dot .

_description_: mandatory string. The description of the parameter.

_raw_type_: mandatory enumerated value. The type of the source value: when a parameter sample is injected into the model, the source value
of the parameter sample must have this type.

_eng_type_: mandatory enumerated value. The output type of the parameter, after the processing.

_eng_unit_: default is empty string. The unit of the parameter engineering value.

_log_repetition_period_: default is 0 (disabled). The minimum log generation period in milliseconds. If an alarm generates
a log within the minimum repetition period window, the log message is skipped and a counter increased. This is a way to
limit log flooding for parameters in case of high sampling rates.

_user_parameter_: default is 'false'. This attribute indicates whether a parameter must be considered a user-parameter,
i.e. not linked to external device parameters but rather settable directly from users, drivers or other ReatMetric elements and
not via a setter element, which is mapped to an activity for dispatching and remote execution. User parameters can be
considered 'internal' parameters, which can be useful to define globally available values and properties, with all the
processing capabilities of validity, calibrations, checks and triggers available for standard parameters.

The _parameter_ node has the following sub-elements:

_validity_: optional, if not provided the parameter is always considered valid. The _validity_ element can contain either
a _match_ element or a _condition_ sub-element. A _match_ element is used to determine the validity based on a comparison
between the value (source or engineering) of a second parameter, and the value specified in the definition, with the related
operator (equal, higher, lower, not equal...). A _condition_ element specifies a Groovy expression that shall return
a boolean value upon evaluation.

_synthetic_: optional, to be provided only if the parameter shall be a synthetic parameter.
A synthetic parameter requires an expression to compute its source value: therefore, injection of
such parameters via the injectParameter() method will be rejected by the processing model.

_default_value_: optional, null if not provided. It allows to specify a default value (either raw or engineering)
that the processing model will initialise as default value upon instantiation.
Uninitialised parameters will have a Java null value as source and engineering value.

_calib_x_: optional (zero or more), no calibration if none is provided. When no calibration is assigned, the source/raw value is simply
assigned as engineering value. When provided, the calibration to be applied is selected by checking the list of specified
calibration in the order they appear in the definition, and the first calibration matching the applicability criterium is
selected and applied. If no applicability criterium is specified, then the calibration is always considered applicable. The
following calibrations are available:

* calib_xy: a list of x,y pairs is defined. The raw value must be defined as a number (integer, real, enumerated).
The engineering value must be defined as a real. The processing model computes the output linked to the provided input
number by linearly interpolating the y-value between the pair that  encloses the x-input. Extrapolation outside the minimum
and maximum x can be activated: it is de-activated by default. In such case, the processing model will reject the attempt
to calibrate a input outside the series-defined boundaries.
* calib_poly: the definition specifies 6 coefficients (from a0 to a5), which compose the polynomial function:
a0 + a1*x + a2*x^2 + a3*x^3 + a4*x^4 + a5*x^5. The raw value must be defined as a number (integer, real, enumerated).
The engineering value must be defined as real.
* calib_log: the definition specifies 6 coefficients (from a0 to a5), which compose the logarithmic function:
1/(a0 + a1*log(x) + a2*log(x)^2 + a3*log(x)^3 + a4*log(x)^4 + a5*log(x)^5). The raw value must be defined as a number
(integer, real, enumerated). The engineering value must be defined as real.
* calib_enum: a list of key,value pairs is defined, plus a default string value. The raw value must be defined as an
integer number or enumerated. The engineering value must be defined as string. The provided input number is mapped to the
corresponding textual value, or to the default value if no correspondence is found.
* calib_range_enum: a list of range-to-value pairs is defined. The raw value must be defined as a number (integer, real,
enumerated). The engineering value must be defined as string. Given the provided input number, the range containing it is
detected, and the corresponding textual value is returned as engineering value. If no range contains the provided input,
the default value is returned.
* calib_expression: input and output values can be of any type. The defined Groovy expression is used to compute the
output value.
* calib_external: input and output values can be of any type. The processing model uses the registered ICalibrationExtension
implementation, as specified in the definition, to request the calibration of the provided input value.

_checks_: optional (zero or more) checks can be specified inside the element _checks_. Checks are applied to the
engineering value of the parameter of a parameter by default (unless differently specified),
if the check applicability criteria is satisfied. If a check does not have an applicability criteria, the check is always
considered to be applied. By default, a violated check immediately raises an alarm: it is possible to modify the severity of
the check, as well as the number of consecutive checks that the check must fail before raising the failure.
The sub-elements of the _checks_ element are:

* limit: the value must be inside the low/high limit specified in the definition. If it is outside the limit, the
check is declared failed.
* expected: the value must match one of the values specified in the definition, otherwise the check is declared failed.
* delta: the difference between the new value and the previous value is computed. If such difference is not within the
low/high limit specified in the definition, the check is declared failed. The absolute (positive) difference can also be used.
* expression: a Groovy expression, returning a boolean value, is defined. If the evaluation of the definition returns
false, then the check is declared failed.
* external: The processing model uses the registered ICheckExtension implementation, as specified in the definition,
to request the check of the provided parameter.

_setter_: optional (zero or one) reference to an existing activity, which shall be used to set the value of the parameter
to a new value. The definition must specify which argument of the activity shall be set to the new value specified by the
user. The activity invocation is complemented by the list of fixed argument values, each mapping to an activity argument.
If such setter is specified, the SetParameterRequest will translate to an activity invocation. It is important to note that
the setter definition must specify a _complete_ activity invocation, i.e. all activity arguments must be specified. An
optional de-calibration can be specified (including inverted enumerations) to convert the value specified as engineering value
into raw value.

_triggers_: optional (zero or more) triggers can be specified inside the element _triggers_ (sub-node _trigger_). Triggers
can be linked to events, which are raised when there is a specific change in the parameter state. The specific change is
specified with the attribute _condition_ (which takes four possible values: ON_NEW_SAMPLE, ON_VALUE_CHANGED, ON_ALARM_RAISED,
ON_BACK_TO_NOMINAL), while the event to raise is specified in the attribute _event_.

===== Events

The _events_ element contains zero or more _event_ elements. An example is provided in the XML fragment below.

[source,xml]
----
<event id="#190"
    location="SUB1.STATE_CHANGE"
    description="Subsystem State Changed event"
    severity="INFO"
    type="Event Type 1"
    inhibition_period="1000"
    log_repetition_period="2000">
</event>
----

The _event_ node has the following attributes:

_id_: mandatory special string. The string is a positive integer number, prefixed with the hash # symbol. The number must be unique among all
system element ids defined in the ReatMetric model under monitoring, including those defined in separate processing models.

_location_: mandatory string. This string represents the location of the event in the hierarchical decomposition. Each
element of the hierarchy is separated by a dot .

_description_: mandatory string. The description of the event.

_severity_: optional, default is INFO. The severity of the event.

_type_: optional, default is empty string. The type of the event.

_inhibition_period_: optional default is 0 (disabled). The number of milliseconds between two reporting of the event. This is a
way to limit event flooding.

_log_repetition_period_: optional, default is 0 (disabled). The minimum log generation period in milliseconds. If an event generates
a log within the minimum repetition period window, the log message is skipped and a counter increased. This is a way to
limit log flooding for events.

_log_enabled_: optional, default is true (enabled). When set to false, the event does not generate log messages.

The _event_ node has the following sub-elements:

_condition_: optional, to be provided only if the event occurrence shall be computed by the processing model. The provided
Groovy expression shall return a boolean value: when a transition false -> true in the condition evaluation is detected, the
processing model raises the event.

===== Activities

The _activities_ element contains zero or more _activity_ elements. An example is provided in the XML fragment below.

[source,xml]
----
<activity id="#79" location="SUB1.REBOOT" description="Reboot subsystem" type="DEV3-BIN-CMD"
    verification_timeout="3000">
    <argument name="delay" raw_type="UNSIGNED_INTEGER" eng_type="UNSIGNED_INTEGER" eng_unit="" />
    <argument name="running" raw_type="UNSIGNED_INTEGER" eng_type="UNSIGNED_INTEGER" eng_unit="" />
    <property key="test1" value="V1" />
    <property key="test2" value="V2" />
    <verification>
        <expression>STATUS == "ON"</expression>
        <symbol name="STATUS" reference="#170" binding="ENG_VALUE" />
    </verification>
</activity>
----

The _activity_ node has the following attributes:

_id_: mandatory special string. The string is a positive integer number, prefixed with the hash # symbol. The number must be unique among all
system element ids defined in the ReatMetric model under monitoring, including those defined in separate processing models.

_location_: mandatory string. This string represents the location of the activity in the hierarchical decomposition. Each
element of the hierarchy is separated by a dot .

_description_: mandatory string. The description of the activity.

_type_: mandatory string. The type of the activity.

_default_route_: optional, null if not set. The route to be used in case no route is specified as part of the activity
invocation request.

_transmission_timeout_: optional, default is 0 (disabled). The number of seconds after entering the transmission state,
before the state of the specific activity occurrence goes in timeout.

_execution_timeout_: optional, default is 0 (disabled). The number of seconds after entering the execution state,
before the state of the specific activity occurrence goes in timeout.

_verification_timeout_: optional, default is 0 (disabled). The number of seconds after entering the verification state,
before the state of the specific activity occurrence goes in timeout.

_expected_duration_: optional, default is 1000. The expected duration of an activity occurrence execution, in milliseconds.

The _activity_ node has the following sub-elements:

_argument_: optional (zero or more), it can be interleaved with _array_ elements. It defines a simple argument with the
given name, type and decalibration function, which is applied if the argument is provided in engineering value.
_array_: optional (zero or more), it can be interleaved with _argument_ elements. It defines an array of values.
_property_: optional (zero or more). It is used to pre-define properties and values to be used as part of an activity
invocation.
_verification_: optional (zero or one), default is null. It is used to specify a Groovy expression, which is executed when the
activity occurrence enters the _VERIFICATION_ state and at every change of the contributing inputs, until the timeout
elapses.

===== Expressions

In the definition of the elements of the processing model, it is possible to use a Groovy expression in several places
(validity conditions, monitoring checks, calibrations, events, activity verification). An expression is composed by two
sub-elements:

_expression_: it contains the expression that it is used to compute the desired value. The type of such value depends on
the use of such expression: for validity conditions, monitoring checks, events and activity verification, the expression
must return a boolean value. Expressions used for synthetic parameters and calibrations can return any value, as long as
the returned value is in line with the declared parameters types.

_symbol_: optional (zero or more). Each _symbol_ specifies the mapping between a variable present in the expression and
a system element or related property in the processing model.

A symbol can be linked to one of the following system element properties using the attribute _binding_:

* PATH: The location of the system entity (as string)
* GEN_TIME: The generation time (as Java java.time.Instant)
* RCT_TIME: The reception time (as Java java.time.Instant)
* ROUTE: The route (as string)
* SOURCE_VALUE: The raw/source value (only for parameters)
* ENG_VALUE: The engineering value (only for parameters)
* ALARM_STATE: The alarm state (as eu.dariolucia.reatmetric.api.model.AlarmState, only for parameters)
* VALIDITY: The validity (as eu.dariolucia.reatmetric.api.parameters.Validity, only for parameters)
* QUALIFIER: The qualifier (as string, only for events)
* SOURCE: The source (as string)
* OBJECT: The bound object (i.e. eu.dariolucia.reatmetric.api.processing.scripting.IParameterBinding for parameters,
eu.dariolucia.reatmetric.api.processing.scripting.IEventBinding for events

An example of a synthetic parameter is provided below. The synthetic parameter computes the maximum value between two
parameters, depending on the value and alarm state of a third parameter.

[source,xml]
----
<parameter id="#1430"
    location="SUB1.MAX_LEVEL"
    description="Subsystem Maximum Voltage Level"
    raw_type="REAL"
    eng_type="REAL"
    eng_unit="mV">
    <synthetic>
        <expression>
            if(COMBINER_VALUE == "COMBINING" &amp;&amp; !COMBINER_ALARM.isAlarm()) {
                return Math.max(LEVEL1, LEVEL2);
            } else {
                return 0;
            }
        </expression>
        <symbol name="LEVEL1" reference="#1421" binding="ENG_VALUE" />
        <symbol name="LEVEL2" reference="#1422" binding="ENG_VALUE" />
        <symbol name="COMBINER_VALUE" reference="#1424" binding="ENG_VALUE" />
        <symbol name="COMBINER_ALARM" reference="#1424" binding="ALARM_STATE" />
    </synthetic>
</parameter>
----